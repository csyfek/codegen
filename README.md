# codegen

Multi-purpose code generator for creating SQL schemas, SQL-Go bindings,
HTTP-REST interfaces, and model libraries from Go packages or existing SQL
databases.

This tool has evolved significantly from its humble beginnings. Those who have
worked with me have probably seen code generated by this tool or one of its
ancestors. 

The first generation of this tool was typically a small web apps with basic HTML
(no JavaScript) interfaces for various kinds of transformations.

In subsequent iterations, it became a command-line tool for creating SQL
bindings and schemas from Go struct definitions.

As my career involved more reverse engineering and language migrations, this
tool has expanded to include the generation of entire REST interfaces and model
libraries from existing databases.

Please note that this tool has not traditionally been consumed by people other
than myself and my coworkers. While I try to keep the documentation up, I do not
intend to ever promise interface stability. Instead, my intention is to preserve
functionality from previous iterations by way of command-line flags.

When in doubt, just execute the 'codegen' binary to see a list of command-line
options.

## SQL Bindings Generation

This tool began its life primarily for generating Go-SQL bindings from Go struct
definitions.

To create these bindings, you will be mostly interested in the 'driver', 'pkg',
'src', and 'dst' will be of most interest to you.

This command will generate bindings from struct definitions within a package:

```
codegen --src=pkg --dst=bindings --driver=mysql --pkg=github.com/jackmanlabs/codegen/types
```

Said bindings will be printed to stdout by default.

The `src` flag specifies the kind of source data you want to use. Acceptable
values are `pkg` and `db`. In the above example, we use the value `pkg` to
indicate that we want to generate bindings for structs in a Go package.

The `dst` flag specifies the kind of data we want out. Acceptable values include
`types`, `control`, `bindings`, `rest`, `schema`, and `everything`. If you're
coming from a previous generation of this tool, you'll be most interested in
`bindings` and `schema`. These will produce Go language bindings for an SQL
database or a schema for an SQL database respectively.

The `driver` flag indicates, in this case, the SQL dialect to use for output.
Acceptable values are `sqlite`, `mysql`, `pg`, and `mssql`. The MySQL and
Postgres dialects are most mature. Please submit bug reports if the generated
SQL troubles you.

Finally, the `pkg` flag indicates the package that you want to use as the data
source (per the `src` flag). Any Go package path (import path) is acceptable as
long as it`s in your GOPATH. Please note that this is not a path on your
filesystem; see https://blog.golang.org/organizing-go-code first if you have
questions.

Please keep in mind that the output will probably not be exactly what you want.
All the code generated by this tool is intended to be modified and optimized for
your application. Some of the code that is output is there purely to make syntax
analyzers happy.

I also use the following package for error reporting:
`github.com/jackmanlabs/errors`. This package has the Stack() method to assemble
a call stack in addition to the error to facilitate debugging. If you don't like
it, it should easy enough to replace it with your own error package or error
messages.

## Technical Debt

I fully acknowledge that I've built some technical debt into this product. The
need to get something working right away has pushed me to write sloppy code that
is just good enough. If you decide you want to clean this up and make it more
extensible, there may be an invitation to a pizza dinner in your future.